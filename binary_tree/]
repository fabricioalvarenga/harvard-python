from __future__ import annotations

class Node:
    ID_COUNTER: int = 0

    def __init__(self, value: int, is_root: bool = False):
        Node.ID_COUNTER += 1

        self._id: int = Node.ID_COUNTER 
        self.value: int = value
        self._is_root: bool = is_root
        self.descending_nodes: list[Child_Node] = []

    @property
    def id(self) -> int: return self._id

    @property
    def is_root(self) -> bool: return self._is_root


class Root_Node(Node):
    def __init__(self, value: int):
        super().__init__(value, is_root = True)


class Child_Node(Node):
    def __init__(self, value: int, ascending_node: Root_Node | Child_Node):
        super().__init__(value)
        self._ascending_node: Root_Node | Child_Node = ascending_node
        self._ascending_node.descending_nodes.append(self)

    @property
    def ascending_node(self) -> Root_Node | Child_Node: return self._ascending_node


def main():
    root_node: Root_Node = Root_Node(10)
    child_node1: Child_Node = Child_Node(20, root_node)
    child_node2: Child_Node = Child_Node(30, root_node)
    child_node3: Child_Node = Child_Node(40, child_node2)

    root_node.descending_nodes.append(child_node1)
    root_node.descending_nodes.append(child_node2)

    node = root_node
    while len(node.descending_nodes) > 0:
        pass
        break

    print(f"Root  Node   => ID: {root_node.id}, Value: {root_node.value}, Descending: {root_node.descending_nodes[0].id}")
    print(f"Child Node 1 => ID: {child_node1.id}, Value: {child_node1.value}, Ascending: {child_node1.ascending_node.id}")
    print(f"Child Node 2 => ID: {child_node2.id}, Value: {child_node2.value}, Ascending: {child_node2.ascending_node.id}, Descending: {child_node2.descending_nodes[0].id}")
    print(f"Child Node 3 => ID: {child_node3.id}, Value: {child_node3.value}, Ascending: {child_node3.ascending_node.id}")


if __name__ == "__main__":
    main()
